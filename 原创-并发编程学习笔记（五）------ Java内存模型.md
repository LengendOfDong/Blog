# 原创：并发编程学习笔记（五）------ Java内存模型

注明：<br/>
参考书作者：方腾飞 魏鹏 程晓明<br/>
参考书目：《Java 并发编程的艺术》

# Java内存模型基础

## 并发编程模型的两个关键问题

在并发编程中，需要处理的两个关键问题：

## Java内存模型的抽象结构

首先明确的是哪些变量需要用到Java内存模型<br/>
共享变量（实例域，静态域和数组元素）会需要Java内存模型<br/>
局部变量，方法定义参数和异常处理器参数不需要Java内存模型<br/>
Java内存模型的抽象示意图：<br/>
<img alt="Java内存模型的抽象" src="https://img-blog.csdnimg.cn/20190713181942327.png?"/><br/>
从上图看，如果线程A和线程B之间要通信的话，必须要经历下面2个步骤：<br/>
1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。<br/>
2）线程B到主内存中去读取线程A之前已更新过的共享变量<br/>
下面举个例子来说明：<br/>
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190713183053546.png?"/><br/>
本地内存A和本地内存B由主内存中共享变量x的副本。假设初始时，这3个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值为1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。<br/>
从整体来看，这两个步骤实际上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。Java内存模型（JMM）通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。

## 从源代码到指令序列的重排序

在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。重排序分为3种类型。<br/>
1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。<br/>
2）指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。<br/>
3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。<br/>
从Java源代码到最终执行的指令序列，会分别经历下面3中重排序，如下图：<br/>
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190713192916343.png?"/><br/>
上图中1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。<br/>
JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

## 并发编程模型的分类

## happens-before简介

从JDK5开始，Java使用新的JSR-133内存模型。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。<br/>
与程序员密切相关的happens-before规则如下：

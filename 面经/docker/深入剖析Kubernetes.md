# 深入剖析Kubernetes

## 云原生大事记

Docker项目给PaaS世界带来的降维打击，其实是它提供了—种非常便利的打包机制。这种机制直接打包了应用程序运行所需要的整个操作系统，从而保证了本地环境和云端环境的高度—致，避免了用户通过‘试错,’来匹配不同运行环境之间差异的痛苦过程。

Docker项目之所以能获得如此高的关注度，一方面是因为它解决了应用打包和发布这一困扰运维人员多年的技术难题；另一方面是因为它第一次把一个纯后端的技术概念，通过非常友好的设计和封装，交到了最广大的开发者群体手里。

Docker项目从发布之初到全面发力，从技术、社区、市场全方位争取到的开发者群体，实际上都是为此后将整个生态吸引到自家PaaS上的一个铺垫。PaaS的定义变成了一套以Docker容器为技术核心，以Docker镜像为打包标准的全新“容器化”思路。

Docker项目在短时间内迅速崛起的3个重要原因：

- Docker镜像通过技术手段解决了PaaS的根本性问题
- Docker容器同开发者之间有着与生俱来的密切关系
- PaaS概念已经深入人心的完美契机



# 容器技术基础

## 从进程开始说起

容器本身的价值非常有限，真正有价值的是容器编排。

操作系统从程序中发现输入数据保存在一个文件中，然后这些数据会被加载到内存中待命。同时，操作系统又读取到了计算加法的指令，这时它就需要指示CPU完成加法操作。而CPU与内存协作进行加法计算，又会使用寄存器存放数值，内存堆栈保存执行的命令和变量。

容器技术的核心功能就是通过约束和修改进程的动态表现，为其创造一个“边界”。

<font color=red>对于Docker等大多数Linux容器来说，Cgroups技术是用来制造约束的主要手段，而Namespace技术是用来修改进程视图的主要方法。</font>

**Namespace的具体解释**

Docker针对运行在容器中运行的程序会重新计算PID，比如PID=1,实际上，在宿主机的操作系统中，它的进程号是另外一个数字，比如PID=100。

在Linux系统中创建线程的系统调用是

```shell
int pid＝clone(main_function, stack_size, CLONE_NEWPID|SIGHLD, NULL)
```

这样新创建的进程会看到一个全新的进程空间，在这个进程空间中，它的PID是1。

多次调用这个clone方法，会创建多个PID Namespace，每个Namespace中应用进程都会认为自己是当前容器里的第1号进程，既看不到宿主机的真正的进程空间，也看不到其他PID Namespace里的具体情况。

<font color=blue>Linux操作系统中还提供了Mount/UTS/IPC/Network和User这些Namespace,用来对各种进程上下文施障眼法，比如Mount Namespace用于让被隔离进程只能看到Namespace里的挂载点信息。</font>

<font color=darkred>容器其实是一种特殊的进程而已</font>。

在使用Docker时，并没有一个真正的Docker容器在宿主机中运行，Docker项目帮助用户启动的还是原来的应用进程，只不过在创建这些进程时，Docker为它们加上了各种各样的Namespace参数。

这些进程只是由于通过Cgroups技术来实现了相互隔离，并通过Namespace技术来修改了应用进程看待整个计算机“视图”的视野，仿佛置身于容器中，这些只不过是障眼法罢了。

## 隔离与限制

用户在容器里运行的应用进程，跟宿主机上的其他进程一样’都由宿主机操作系统统一管理，只不过这些被隔离的进程拥有额外设置的Namespace参数。而Docker项目在这里扮演的角色，更多的是旁路式的辅助和管理工作。

![容器技术架构图](../../img/容器技术架构图.png)
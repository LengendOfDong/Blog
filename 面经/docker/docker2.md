# 十一、核心实现技术

## 核心实现技术

Docker目前采用了标准的C/S架构，包括客户端、服务端两大核心组件，同时通过镜像仓库来存储镜像。

客户端和服务端既可以运行在一个机器上，也可以通过socket或者RESTful API进行通信。

### 服务端

Docker服务端一般在宿主主机后台运行，dockerd作为服务端接受来自客户的请求，并通过containerd具体处理与容器相关的请求，包括创建/运行/删除容器等。服务端主要包括四个组件：

- dockerd:为客户端提供RESTful API，响应来自客户端的请求，采用模块化的架构，通过专门的Engine模块来分发管理各个来自客户端的任务。可以单独升级。
- docker proxy: 是dockerd的子进程，当需要进行容器端口映射时，docker-proxy完成网络映射配置。
- containerd：是dockerd的子进程，提供gRPC接口响应来自dockerd的请求，对下管理runC镜像和容器环境。可以单独升级；
- containerd-shim:是containerd的子进程，为runC容器提供支持，同时作为容器内进程的根进程。



### 客户端

Docker客户端为用户提供一系列可执行命令，使用这些命令可实现与Docker服务端交互。

用户使用的Docker可执行命令即为客户端程序。与Docker服务端保持运行方式不同，客户端发送命令后，等待服务端返回；一旦收到返回后，客户端立刻执行结束并退出。

客户端默认通过本地的unix://var/run/docker.sock套接字向服务端发送命令。

### 镜像仓库

镜像仓库提供了对不同存储后端的支持，存放镜像文件，并且支持RESTful API，接收来自docked的命令，包括拉取、上传镜像等。

## 命名空间

命名空间是Linux内核的一个强大特性，为容器虚拟化的实现带来极大便利。利用这一特性，每个容器都可以拥有自己单独的命名空间，运行在其中的应用就像是在独立的操作系统环境中一样。命名空间机制保证了容器之间彼此互不影响。

要想实现虚拟化，除了要实现对内存/cpu/网络ID/硬盘/存储空间等的限制外，还要实现文件系统、网络、PID、UID、IPC等相互隔离。前者相对容器实现一些，后者需要宿主主机系统的深入支持。

### 进程命名空间

Linux通过进程命名空间管理进程号，对于同一进程，在不同的命名空间中，看到的进程号不相同。

每个进程命名空间有一套自己的进程号管理方法。进程命名空间是一个父子关系的结构，子空间中的进程对于父空间是可见的。新fork出的一个进程，在父命名空间和子命名空间将分别对应不同的进程号。

在容器内的进程空间中，则把docker-containerd-shim进程作为0号根进程（类似宿主系统中0号根进程idle)，while进程的进程号则变为1（类似宿主系统中1号初始化进程/sbin/init)。容器内只能看到docker-containerd-shim进程往下的子进程空间，而无法获知宿主机上的进程信息。




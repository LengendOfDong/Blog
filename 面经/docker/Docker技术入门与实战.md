# 一、初识Docker

在云计算时代，虚拟化技术无疑是整座信息技术大厦最核心的一块基石。

虚拟化既可以通过硬件模拟来实现，也可以通过操作系统来实现。

容器虚拟化技术充分利用操作系统本身的机制和特性，可以实现轻量级的虚拟化，其中Docker就是主要的代表。

Docker通过对应用组件的封装、分发、部署、运行等生命周期的管理，达到应用软件级别的“一次封装，到处运行”。

> 容器技术的准确描述：
>
> 容器有效地将由单个操作系统管理的资源划分到孤立的组中，以便更好地在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心CPU本地运行指令，而不需要任何专门的解释机制。此外，也避免了准虚拟化和系统调用替换中的复杂性。

## Docker容器虚拟化的好处

对开发和运维来说，最希望的就是一次性地创建或配置，可以在任意环境、任意时间让应用正常地运行。

Docker在开发和运维过程中，有如下几个方面的优势：

- 更快速的交付和部署

​	开发人员可以使用镜像快速构建一套标准的开发环境。而测试和运维人员可以直接使用相同环境来部署代码。

- 更高效的资源利用

 	内核级虚拟化，可以实现更高的性能，同时对资源的额外需求很低。

- 更轻松的迁移和扩展

​	可以在任意平台上运行，包括物理机/虚拟机/公有云/私有云/个人电脑/服务器

- 更简单的更新管理

​	使用Dockerfile，只需小小的配置修改，就可以替代以往大量的更新操作，并且所有修改都是以增量的方式来进行分发和更新。

## Docker与虚拟机比较

<font color=red> Docker容器很快，启动和停止可以在秒级实现。</font>
- Docker容器对系统资源需求很少，一台主机可以同时运行数千个Docker容器
- Docker通过类似Git的操作来方便用户获取/分发和更新应用镜像，指令简明，学习成本较低
- Docker通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率。

传统虚拟机方式运行N个不同的应用就要启动N个虚拟机，而且每个虚拟机都需要单独分配内存/磁盘等资源，而Docker只需要启动N个隔离的容器，并将应用放到容器内即可。

Docker利用Linux系统上的多种防护机制实现了严格可靠的隔离，另外Docker还引入了安全选项和镜像签名机制，极大地提高了使用Docker的安全性。

| 特性       | 容器               | 虚拟机     |
| ---------- | ------------------ | ---------- |
| 启动速度   | 秒级               | 分钟级     |
| 硬盘使用   | 一般位MB           | 一般位GB   |
| 性能       | 接近原生           | 弱于       |
| 系统支持量 | 单机支持上千个容器 | 一般几十个 |
| 隔离性     | 安全隔离           | 完全隔离   |

通过图能够清晰地看出虚拟机和Docker之间的区别：
![虚拟机与Docker对比](../../img/虚拟机与Docker对比.png)

## 虚拟化与Docker

虚拟化在维基百科上的定义：
<font color=purple> 在计算机技术中，虚拟化是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用比原本的组态更好的方式来应用这些资源。</font>

虚拟化技术的核心是对资源进行抽象，从大类上分，可分为基于硬件的虚拟化和基于软件的虚拟化。其中，真正意义上的基于硬件的虚拟化技术并不多见。
基于软件的虚拟化从对象所在的层次，又可以分为应用虚拟化和平台虚拟化（通常说的虚拟机技术即属于这个范畴）。

应用虚拟化：指的是一些模拟设备或Wine这样的软件。
平台虚拟化：可以细分为如下几个子类：

- <font color=red>完全虚拟化：虚拟机模拟完整的底层硬件环境和特权指令的执行过程，客户操作系统无需进行修改。例如VMware Workstation/VirtualBox/QEMU等</font>
- <font color=green>硬件辅助虚拟化：利用硬件（主要是CPU）辅助支持（目前x86体系结构上可用的硬件辅助虚拟化技术包括Intel-V和AMD-V）处理敏感指令来实现完全虚拟化的功能，客户操作系统无需修改，例如VMware Workstation/Xen/KVM</font>
- <font color=skyBlue>部分虚拟化：只针对部分硬件资源进行虚拟化，客户操作系统需要进行修改。现在有些虚拟化技术的早期版本仅支持部分虚拟化。</font>
- <font color=chartreuse> 超虚拟化：部分硬件接口以软件的形式提供给客户机操作系统，客户操作系统需要进行修改，例如早期的Xen</font> 
- <font color=blue>操作系统级虚拟化：内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程。容器相关技术即在这个范畴。</font>
  Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。

### 在Windows上运行docker

Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。
因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。
在 Windows 上部署 Docker 的方法都是先安装一个虚拟机，并在安装 Linux 系统的的虚拟机中运行 Docker。
Docker Desktop 是 Docker 在 Windows 10 和 macOS 操作系统上的官方安装方式，这个方法依然属于先在虚拟机中安装 Linux 然后再安装 Docker 的方法。

# 二、Docker的核心概念和安装

## Docker镜像

 Docker镜像类似于虚拟机镜像，可以将它理解为一个面向Docker引擎的只读模板，包含了文件系统。
 镜像是创建Docker容器的基础，通过版本管理和增量的文件系统，Docker提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以直接从网上下载一个已经做好的应用镜像，并通过简单的命令就可以直接使用。

## Docker容器

 Docker容器类似于一个轻量级的沙箱，Docker利用容器来运行和隔离应用。
 容器是从镜像创建的应用运行实例，可以将其启动、开始、停止、删除，而这些容器都是相互隔离、互不可见的。
 镜像自身是只读的，容器从镜像启动时，Docker会在镜像的最上层创建一个可写层，镜像本身将保持不变。

## Docker仓库

 Docker仓库类似于代码仓库，是Docker集中存放镜像文件的场所。
 注册服务器是存放仓库的地方，其上往往存放这多个仓库，每个仓库集中存放某一类镜像，通过不同的标签来进行区分。
 例如存放Ubuntu操作系统镜像的仓库，称为Ubuntu仓库。

 当用户创建了自己的镜像之后可以使用push命令将它上传到指定的公有或者私有仓库。这样用户下次在另外一台机器上使用该镜像时，只需将其从仓库上pull下来就可以了。

# 三、镜像

## 获取镜像

使用docker pull命令从网络上下载镜像。格式为docker  pull  NAME[:TAG]
如果不指定TAG，则默认会选择latest标签，即下载仓库中最新版本的镜像。
镜像文件一般由若干层组成，下载过程中会获取输出镜像的各层信息。层其实是AUFS(高级联合文件系统)中的重要概念，是实现增量保存与更新的基础。

## 查看镜像信息

docker images 命令可以列出本地主机上已有的镜像

![docker images](../../img/docker_image.png)

在列出信息中，可以看到几个字段信息：

- 来自于哪个仓库，比如ubuntu仓库

- 镜像的标签信息，比如14.04

- 镜像的ID号（唯一）

- 创建时间

- 镜像大小

使用docker  tag命令为本地镜像添加新的标签，通过镜像ID可以看出它们实际上是同一个镜像文件。

![docker tag](../../img/docker_tag.png)




































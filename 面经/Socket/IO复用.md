# I/O复用
select/poll/epoll都是I/O多路复用的具体实现，select出现最早，之后是poll,再是epoll。

##  比较
### 1.功能
select和poll的功能基本相同，不过在一些实现细节上有所不同。
- select会修改描述符，而poll不会
- select的描述符类型使用数组实现，FD_SETSIZE大小默认为1024，因此默认只能监听少于1024个描述符。如果要监听更多描述符的话，需要修改FD_SETSIZE之后重新编译；而poll没有描述符数量的限制。
- poll提供了更多的事件类型，并且对描述符的重复利用上比select高。
- 如果一个线程对某个描述符调用了select或者poll,另一个线程关闭了该描述符，会导致调用结果不确定

### 2.速度
select和poll速度都比较慢，每次调用都需要将全部描述符从你那女过应用进程缓冲区复制到内核缓冲区。

### 3.可移植性
几乎所有的系统都支持select，但是只有比较新的系统支持poll.

## epoll
epoll_ctl()用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将I/O准备好的描述符加入到一个链表中管理，进程调用epoll_wait()便可以得到事件完成的描述符。

epoll仅适用于Linux OS.

epoll比select和poll更加灵活且没有描述符数量限制。

epoll对多线程编程更有友好，一个线程调用了epoll_wait()另一个线程关闭了同一个描述符也不会产生像select和poll的不确定情况。

## 工作模式
epoll的描述符事件有两种触发模式：LT(level trigger)和ET(edge trigger)

### 1.LT模式
当epoll_wait()检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用epoll_wait()会再次通知进程。是一种默认的一种模式，并且同事支持Blocking和No-Blocking。

### 2.ET模式
和LT模式不同的是，通知之后进程必须立即处理事件，下次再调用epoll_wait()时不会再得到事件到达的通知

很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。只支持No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

## 应用场景
很容易产生一种错觉认为只要用epoll就可以了，select和poll都已经过时了，其实它们都有各自的使用场景。

### 1.select应用场景

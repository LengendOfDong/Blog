# IOC理论
IoC全称为InversionOfControl，翻译为控制反转。它还有一个别名为DI（Dependency Injection）,即依赖注入。

如何理解“控制反转”好呢？理解好它的关键在于我们需要回答如下四个问题：
- 谁控制谁？
- 控制什么？
- 为何是反转？
- 哪些方面反转了？

在回答这四个问题之前，我们先看IOC的定义：
> 所谓IOC，就是由SpringIOC容器来负责对象的生命周期和对象之间的关系。

举个例子，通常很多时候我们都是自己做饭菜，但是准备饭菜的过程复杂而且又繁琐。从准备材料，到制作过程，以及最后的收拾厨房，都是很麻烦的事情。

但是思考一下，我们真的需要每次都需要自己去做饭菜吗？我们依赖对象并不是依赖该对象本身，而是依赖它所提供的服务，只要在我们需要它的时候，它能够及时提供服务即可，至于它是主动创建的还是别人送给我们的，这并不是十分重要。所以，做饭菜这件事情可以通过平台点外卖的方式，整个制作的过程自己并不需要关心，我们所需要做的就是给平台提供自己需要的条件，比如点个炒饭，少油少盐，多放菜，等炒饭到了只管吃就行了。

从整个过程来看，从自己需要吃饭自己做，变成了去平台上点外卖，将原来的主动变成了现在的被动接受（符合我们的要求），更加简洁轻便。

![控制反转](https://github.com/LengendOfDong/Blog/blob/master/img/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC.png)

在没有引入IoC的时候，被注入的对象直接依赖于被依赖的对象，有了IoC后，两者及其他们的关系都是通过IoC Service Provider来统一管理维护的。被注入的对象需要什么，直接跟IoC Service Provider打声招呼，后者就会把相应的被依赖对象注入到被注入的对象中，从而达到 IOC Service Provider 为被注入对象服务的目的。

现在在看上面那四个问题，答案就显得非常明显了:
- 谁控制谁：在传统的开发模式下，我们都是采用直接 new 一个对象的方式来创建对象，也就是说你依赖的对象直接由你自己控制，但是有了 IOC 容器后，则直接由 IoC 容器来控制。所以“谁控制谁”，当然是 IoC 容器控制对象。
- 控制什么：控制对象。
- 为何是反转：没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。
- 哪些方面反转了：所依赖对象的获取被反转了。


# constructor-arg子元素
举个例子：
```java
public class StudentService {
    private String name;

    private Integer age;

    private BookService bookService;

    StudentService(String name, Integer age, BookService bookService){
        this.name = name;
        this.age = age;
        this.bookService = bookService;
    }
}

    <bean id="bookService" class="org.springframework.core.service.BookService"/>

    <bean id="studentService" class="org.springframework.core.service.StudentService">
        <constructor-arg index="0" value="chenssy"/>
        <constructor-arg name="age" value="100"/>
        <constructor-arg name="bookService" ref="bookService"/>
    </bean>
```
StudentService定义一个构造函数，配置文件中使用constructor-arg元素对其配置，该元素可以实现对StudentService自动寻找对应的构造函数，并在初始化的时候将值当做参数进行设置。

parseConstructorArgElements()方法完成constructor-arg子元素的解析。
```java
public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {
        NodeList nl = beanEle.getChildNodes();
        for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
            if (isCandidateElement(node) && nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {
                parseConstructorArgElement((Element) node, bd);
            }
        }
    }
```

遍历所有子元素，如果为constructor-arg则调用parseConstructorArgElement()进行解析。
```java
public void parseConstructorArgElement(Element ele, BeanDefinition bd) {
        // 提取 index、type、name 属性值
        String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);
        String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);
        String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

        // 如果有index
        if (StringUtils.hasLength(indexAttr)) {
            try {
                int index = Integer.parseInt(indexAttr);
                if (index < 0) {
                    error("'index' cannot be lower than 0", ele);
                }
                else {
                    try {
                        // 构造一个 ConstructorArgumentEntry 并将其加入到 ParseState 中
                        this.parseState.push(new ConstructorArgumentEntry(index));

                        // 解析 ele 对应属性元素
                        Object value = parsePropertyValue(ele, bd, null);

                        // 根据解析的属性元素构造一个 valueHolder 对象
                        ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
                        if (StringUtils.hasLength(typeAttr)) {
                            valueHolder.setType(typeAttr);
                        }
                        if (StringUtils.hasLength(nameAttr)) {
                            valueHolder.setName(nameAttr);
                        }
                        //把值typeAttr,nameAttr,以及source都塞入到valueHolder中
                        valueHolder.setSource(extractSource(ele));

                        // 不允许重复指定相同参数
                        if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {
                            error("Ambiguous constructor-arg entries for index " + index, ele);
                        }
                        else {
                            // 加入到 indexedArgumentValues
                            bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);
                        }
                    }
                    finally {
                        this.parseState.pop();
                    }
                }
            }
            catch (NumberFormatException ex) {
                error("Attribute 'index' of tag 'constructor-arg' must be an integer", ele);
            }
        }
        else {
            try {
                this.parseState.push(new ConstructorArgumentEntry());
                Object value = parsePropertyValue(ele, bd, null);
                ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
                if (StringUtils.hasLength(typeAttr)) {
                    valueHolder.setType(typeAttr);
                }
                if (StringUtils.hasLength(nameAttr)) {
                    valueHolder.setName(nameAttr);
                }
                valueHolder.setSource(extractSource(ele));
                bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);
            }
            finally {
                this.parseState.pop();
            }
        }
    }
```
首先获取index、type、name三个属性值，然后根据是否存在index来区分。其实两者逻辑差不多，总共分为如下几个步骤（以有index为例）：
- 构造ConstructorArgumentEntry对象并将其加入到ParseState队列中，ConstructorArgumentEntry表示构造函数的参数
- 调用parsePropertyValue()解析constructor-arg子元素，返回结果值
- 根据解析的结果值构造ConstructorArgumentValues.ValueHolder 实例对象
- 将type、name封装到ConstructorArgumentValues.ValueHolder 中，然后将 ValueHolder 实例对象添加到 indexedArgumentValues 中。

无index的处理逻辑差不多，只是几点不同：构造ConstructorArgumentEntry对象时是调用无参构造函数，最后是将ValueHolder实例添加到genericArgumentValues 中。 parsePropertyValue() 对子元素进一步解析。
```java
 public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {
        String elementName = (propertyName != null) ?
                "<property> element for property '" + propertyName + "'" :
                "<constructor-arg> element";

        NodeList nl = ele.getChildNodes();
        Element subElement = null;
        for (int i = 0; i < nl.getLength(); i++) {
            Node node = nl.item(i);
            // meta 、description 不处理
            if (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&
                    !nodeNameEquals(node, META_ELEMENT)) {
                // Child element is what we're looking for.
                if (subElement != null) {
                    error(elementName + " must not contain more than one sub-element", ele);
                }
                else {
                    subElement = (Element) node;
                }
            }
        }

        // 解析 ref 元素
        boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);
        // 解析 value 元素
        boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);

        // constructor-arg 子元素有两种情况不存在
        // 1. 即存在 ref 又存在 value
        // 2. 存在 ref 或者 value，但是又有子元素
        if ((hasRefAttribute && hasValueAttribute) ||
                ((hasRefAttribute || hasValueAttribute) && subElement != null)) {
            error(elementName +
                    " is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element", ele);
        }

        if (hasRefAttribute) {
            // 获取 ref 属性值
            String refName = ele.getAttribute(REF_ATTRIBUTE);
            if (!StringUtils.hasText(refName)) {
                error(elementName + " contains empty 'ref' attribute", ele);
            }
            // 将 ref 属性值构造为 RuntimeBeanReference 实例对象
            RuntimeBeanReference ref = new RuntimeBeanReference(refName);
            ref.setSource(extractSource(ele));
            return ref;
        }
        else if (hasValueAttribute) {
            // 解析 value 属性值，构造 TypedStringValue 实例对象
            TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));
            valueHolder.setSource(extractSource(ele));
            return valueHolder;
        }
        else if (subElement != null) {
            // 解析子元素
            return parsePropertySubElement(subElement, bd);
        }
        else {
            // Neither child element nor "ref" or "value" attribute found.
            error(elementName + " must specify a ref or value", ele);
            return null;
        }
    }
```


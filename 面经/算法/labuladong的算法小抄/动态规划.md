# 动态规划

动态规划问题的一般形式就是求最值，求解动态规划的核心问题就是穷举，穷举所有可行的答案之后，再找最值。

首先列出正确的状态转移方程，才能正确地穷举。

其次需要判断算法是否具备最优子结构，是否能够通过子问题的最值得到原问题的最值。

最后动态规划问题存在重叠子问题，需要使用备忘录或者DP TABLE来进行优化剪枝。



思维框架：明确base case -> 明确状态 -> 明确选择 -> 定义dp数组/函数的含义

动态规划的框架：

```java
# 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

自顶向下的解法是递归求解，自底向上的解法是递推求解。

比如斐波那契数列的问题，递归的解法是f(n - 1) + f(n - 2) -> f(1) + f(2), 而递推的解法是 f(1) + f(2) ->  f(n - 1) + f(n - 2)。 所以递推的解法使用的是循环迭代的方式，从最小的下标开始。

变量中的值是一种状态，平时说的有状态无状态，就是变量中是否存有值，所以状态转移就是两个变量或者多个变量的值或者状态推得到另一个变量的值或者状态。

状态转移更像是数学中的数学归纳法。



**递归算法的时间复杂度分析：子问题总数 x 解决每个子问题所需的时间**。

子问题总数为递归树的节点个数，虽然递归树会进行剪枝，但是可以通过最坏的情况来估计时间复杂度。







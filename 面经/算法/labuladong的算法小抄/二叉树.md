# 二叉树

数组和单链表都可以看成是特殊的二叉树。

所以数组和单链表既可以使用迭代的方式遍历，也可以使用递归的方式遍历。

二叉树的遍历一般都是递归的方式。



## 递归

```java
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}
```

1)如果倒序打印一条链表的节点值

由于是倒序位置，所以在后序位置进行处理，本质是利用递归的堆栈来处理。

前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点。

前序位置的代码在刚刚进入一个二叉树节点的时候执行。

后序位置的代码在将要离开一个二叉树节点的时候执行。

中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。



递归可以模拟栈的结构，也就是只有前序位置和后序位置。

递归可以模拟二叉树的结构，也就是，前中后序的位置。



二叉树的递归解法可以分成两类思路：

- 遍历一遍二叉树得到答案

- 通过分解问题计算出答案

比如：遍历二叉树

遍历解法：

```java
List<Integer> res = new LinkedList<>();

// 返回前序遍历结果
List<Integer> preorderTraverse(TreeNode root) {
    traverse(root);
    return res;
}

// 二叉树遍历函数
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    res.add(root.val);
    traverse(root.left);
    traverse(root.right);
}
```

分解子问题解法：

```java
// 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果
List<Integer> preorderTraverse(TreeNode root) {
    List<Integer> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    // 前序遍历的结果，root.val 在第一个
    res.add(root.val);
    // 利用函数定义，后面接着左子树的前序遍历结果
    res.addAll(preorderTraverse(root.left));
    // 利用函数定义，最后接着右子树的前序遍历结果
    res.addAll(preorderTraverse(root.right));
    return res;
}
```

遍历二叉树就是通过辅助函数和外部变量，在遍历二叉树的过程中，对外部变量进行动态更新。

分解子问题就是在返回的左右子树的结果上进行判断，总是写在后序的位置上。



中序位置主要用在BST(二叉查找树)中，BST的中序遍历是遍历有序数组。

前序位置的代码只能从函数参数中获取父节点传来的数据，但是后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。后序能够获得更多的数据，传入的和返回的。

通过问题也能得知是应该用前序位置还是后序位置，如果问题只涉及到父节点传来的参数，那么可以使用前序位置；如果问题不仅涉及到父节点传来的参数，同时涉及到之后的节点，或者说只跟后续子节点有关时，可以考虑使用后序位置。

举例说明：

1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？（只涉及到父节点的数据，跟子节点没有关系）

2、如何打印出每个节点的左右子树各有多少节点？（与后面的子节点都有关系，当前节点的结果是由左右子树的节点推出的，那么应该考虑使用后序位置）

也就是说，如果发现题目与子树有关，那么差不多就需要在后序位置写代码了，处理子树的返回值。





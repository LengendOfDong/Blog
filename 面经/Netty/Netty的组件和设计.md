# Channel、EventLoop和ChannelFuture
Channel:Socket

EventLoop:控制流、多线程处理、并发

ChannelFuture:异步通知

## Channel接口
基本的I/O操作（bind(),connect()、read()和write()依赖于底层网络传输所提供的原语）。在基于Java的网络编程中，基本的构造时class Socket。Netty的Channel接口所提供的API，大大地降低了直接使用Socket类的复杂性。

## EventLoop接口
EventLoop定义了Netty的核心抽象，用于处理连接的生命周期中所发生的事件。

Channel、EventLoop、Thread和EventLoopGroup之间的关系如下：
- 一个EventLoopGroup包含一个或者多个EventLoop
- 一个EventLoop在它的生命周期内只和一个Thread绑定
- 所有由EventLoop处理的I/O事件都将在它专有的Thread上被处理
- 一个Channel在它的生命周期内只注册一个或多个Channel
- 一个EventLoop可能会被分配给一个或者多个Channel

## ChannelFuture
ChannelFuture看作是将来要执行的操作的结果的占位符。Netty中所有的I/O操作都是异步的，因为一个操作可能不会立即返回，所以我们需要一种用于在之后的某个时间点确定其结果的方法。Netty提供了ChannelFuture接口，其addListener()方法注册了一个ChannelFutureListener,以便在某个操作完成时（无论是否成功）得到通知。

# ChannelHandler和ChannelPipeline
ChannelHandler可专门用于几乎任何类型的动作，例如将数据从一种格式转换为另一种格式，或者处理转换过程中所抛出的异常。

ChannelInBoundHandler是一个经常实现的子接口，这种类型的ChannelHandler接受入站事件和数据，这些数据随后将会被应用程序的业务逻辑所处理。

## ChannelPipeline
ChannelPipeline为ChannelHandler链提供了容器，并定义了用于在该链上传播入站和出站事件流的API。

ChannelHandler安装到ChannelPipeline中的过程如下所示：
- 一个ChannelInitializer的实现被注册到了ServerBootStrap中
- 当ChannelInitializer.initChannel()方法被调用时，ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler.
- ChannelInitializer将它自己从ChannelPipeline中移除。

使得事件流经ChannelPipeline是ChannelHandler的工作，它们是在应用程序的初始化或者引导阶段被安装的。这些对象接收事件、执行他们所实现的处理逻辑，并将数据传递给链中的下一个ChannelHandler。

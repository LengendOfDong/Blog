# Netty内置的传输
Netty内置了一些可拆箱即用的传输。并不是它们所有的传输都支持每一种协议，所以需要选择一个和应用程序所使用的协议相容的传输。

NIO： 使用java.nio.channels包作为基础，基于选择器的方式。

Epoll: 由JNI驱动的epoll()和非阻塞IO。这个传输支持只有在Linux上可用的多种特性，如SO_REUSEPORT,比NIO传输更快，而且是完全非阻塞的。

OIO：使用java.net包作为基础，使用阻塞流。

Local：可以在VM内部通过管道进行通信的本地传输。

Embedded： Embedded传输，允许使用ChannelHandler而又不需要一个真正的基于网络的传输，这在测试你的ChannelHandler实现时非常有用。

- 非阻塞代码库：如果你的代码库中没有阻塞调用（或者你能够限制他们的范围），那么在Linux上使用NIO或者epoll始终是个好主意。虽然NIO/epoll旨在处理大量的并发连接，但是在处理较小数目的并发连接时，它也能很好的工作，尤其是考虑到它在连接之间共享线程的方式。

- 阻塞代码库：正如我们已经指出的，如果你的代码库严重地依赖于阻塞I/O，而且你的应用程序也有一个相应的设计，那么在你尝试将其直接转换为Netty的NIO传输时，你将可能遇到和阻塞相关的问题。可以考虑分阶段进行迁移，先将代码转换成OIO的方式，等之后再迁移到NIO（或者使用epoll,如果你在使用Linux）

- 在同一个JVM内部的通信，不需要通过网络来暴露服务，是Local传输的完美用例。这将消除所有真实网络操作的开销，同时仍然使用你的Netty代码库。如果随后需要通过网络暴露服务，那么你将只需要把传输修改为NIO或者OIO即可。

- 测试你的ChannelHandler实现：如果你想要为自己的ChannelHandler实现编写单元测试，那么请考虑使用Embedded传输。这既便于测试你的代码，又不需要创建大量的模拟（mock）对象

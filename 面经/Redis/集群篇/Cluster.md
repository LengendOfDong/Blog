# Cluster
Redis Cluster集群是由三个Redis节点组成，每个节点负责整个集群的一部分数据。它们相互连接组成一个对等的集群，它们之间通过一种特殊的二进制协议交互集群信息。

Redis Cluster将所有数据划分为16384个槽位，它比Codis的1024个槽位划分得更为精细。每个节点负责其中一部分槽位。槽位的信息存储于每个节点中，不需要另外的分布式存储空间来存储节点信息。

当客户端来连接集群时，会获得一份槽位配置信息，这样当客户端要查找某个key时，可以直接定位到目标节点。

## 槽位定位算法
Redis Cluster默认会对key值使用crc16算法进行hash，得到一个整数值，然后用这个整数值对16384进行取模来得到具体槽位。

Redis Cluster还允许用户强制把某个key挂在特定槽位上。通过在key字符串里面嵌入tag标记，这就可以强制key所挂槽位等于tag所在的槽位。
```java
def HASH_SLOT(key)
    s = key.index "{"        # 查找key中有无{标记
    if s
        e = key.index"}", s + 1     # 查找key中有无}标记，没有就默认s+1
        if e && e != s+1             # e存在并且不等于s+1,说明{}中不为空
          key = key[s+1..e-1]        # 取出key中的tag标记
        end
    end
    crc16(key) % 16384              # tag标记所在槽位就是key被强制挂的槽位
end
```

## 迁移
迁移工具redis-trib首先会在源节点和目标节点设置好中间状态，然后一次性获取节点槽位的所有key列表，再挨个key进行迁移。

每个key的迁移过程是以源节点作为目标节点的”客户端“，源节点对当前的key执行dump指令得到序列化内容，然后通过”客户端“向目标节点发送restore指令携带序列化的内容作为参数，目标节点再进行反序列化就可以将内容恢复到目标节点的内存中，然后返回”客户端“OK，源节点收到后再把当前节点key删除掉就完成了单个key迁移过程。

大致流程如下： 从源节点获取内容 -> 存到目标节点 -> 从源节点删除内容

迁移过程是同步的，在目标节点执行restore指令到源节点删除key之间，源节点的主流程会处于阻塞状态，直到key被成功删除。所以key的内容如果很大，会同时导致源节点和目标节点同时卡顿，影响集群的稳定性。

## 可能下线（PFail）和 确定下线（Fail）
因为Redis Cluster是去中心化的，一个节点认为某个节点失联了并不代表所有节点都认为它失联了，所以集群还得经过一次协商的过程，只有当大多数节点都认定某个节点失联了，集群才认为该节点需要进行主从切换来容错。

Redis集群节点采用Gossip协议来广播自己的状态以及改变整个集群的认知。如果收到了某个节点失联的节点数量已经达到了集群的大多数，就可以标记该失联节点为确定下线状态，然后向整个集群广播，强迫其他节点也接受该节点已经下线的事实，并立即对该失联节点进行主从切换。（少数服从多数，篡权夺位）

## 槽位迁移感知
Cluster有两个特殊的error指令，一个是MOVED，一个是ASKING。

MOVED指令用来纠正槽位。指令发送错误节点，客户端接收到MOVED指令和正确的目标节点地址，客户端会刷新自己的槽位关系表，然后重试指令。

ASKING是用来临时纠正槽位的。当前正在迁移中，指令发送到旧节点，客户端接收返回的asking error和目标节点地址，客户端会去尝试目标节点，客户端不会刷新自己的槽位关系，因为它只是临时纠正该指令的槽位信息，不影响后续指令。


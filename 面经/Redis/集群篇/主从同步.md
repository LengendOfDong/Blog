# 主从同步
CAP原理：
- C：Consistent,一致性
- A：Availability,可用性
- P：Partition tolerance,分区容忍性

分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫做**网络分区**

在网络分区发生时，因为网络断开造成的数据不一致，如果追求**一致性**，那么就不能再对外提供服务，如果追求**可用性**，那么就需要放弃**一致性**。

用一句话来概括CAP原理就是：当网络分区发生时，一致性和可用性两难全。

## 最终一致
Redis的主从数据是异步同步的，所以分布式Redis系统并不满足**一致性**要求，当客户端在Redis的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以Redis满足**可用性**。

Redis保证**最终一致性**，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，但一旦网络恢复，从节点会采用多种策略努力追赶，继续尽力保持和主节点一致。

## 增量同步
Redis同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存buffer中，然后异步将buffer中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一边向主节点反馈自己同步到哪里了（偏移量）。

Redis的复制内存buffer是个定长数组，如果内存buffer满了，就会从头覆盖里面的内容。

当网络不好，从节点不能及时和主节点进行同步，当网络恢复时，主节点中很多没有同步的指令在内存buffer中有可能被后续的指令覆盖掉了，这时需要用到**快照同步**。

## 快照同步
快照同步首先需要在主节点上进行一次bgsave，将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。

从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空，加载完毕后通知主节点继续进行增量同步。

如果快照同步时间过长，或者复制buffer设置得太小，那么同步期间的增量指令又会被覆盖，那么就又会发起快照同步，造成快照同步的死循环。

所以需要配置一个合适的复制buffer大小参数，避免快照同步的死循环。同样单个Redis的内存不宜设置过大，设置过大就会导致rdb文件过大。

## 增加从节点
当从节点增加到集群中时，需要先进行一次全量的快照同步，同步完成后再进行增量同步。
所以单个Redis的内存不宜过大，内存太大会导致 rdb 文件过大，主从全量同步延迟太长，然后会造成快照同步的死循环。

## 无盘复制
主节点在进行快照同步时，会进行很耗时的文件IO操作，尤其是当系统正在进行AOF的fsync操作时，如果发生快照同步，fsync将会被推迟执行，这就会严重影响主节点的服务效率。

无盘复制是指主服务直接通过套接字将快照内容发送到从节点，生成快照是一个遍历的过程，主节点一边遍历内存，一边将序列化的内容发送到从节点，从节点还是和之前一样，先将接受到的内容存储到磁盘文件中，再进行一次性加载。

## wait指令
Redis的复制是异步执行的，wait指令可以让异步复制变身同步复制，确保系统的强一致性。

wait有两个参数，第一个参数是从节点的数量N，第二个参数是时间t,以毫秒为单位。两个参数的含义是：等待wait指令之前的所有写操作同步到N个从节点（也就是确保N个从节点的同步没有滞后）,最多等待时间t。如果时间t=0,表示无限等待直到N个节点同步完成。
```java
127.0.0.1:6379> wait 1 10000
(integer) 0
(10.03s)
127.0.0.1:6379> wait 1 0

```
上面例子中，由于没有配置从节点，所以当t=10000时，等待10.03s就返回了，当t=0时，就会阻塞在那里无限等待。

## 总结
主从复制是Redis分布式的基础，Redis的高可用离开了主从复制将无从进行。

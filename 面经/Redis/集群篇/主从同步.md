# 主从同步
CAP原理：
- C：Consistent,一致性
- A：Availability,可用性
- P：Partition tolerance,分区容忍性

分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫做**网络分区**

在网络分区发生时，因为网络断开造成的数据不一致，如果追求**一致性**，那么就不能再对外提供服务，如果追求**可用性**，那么就需要放弃**一致性**。

用一句话来概括CAP原理就是：当网络分区发生时，一致性和可用性两难全。

## 最终一致
Redis的主从数据是异步同步的，所以分布式Redis系统并不满足**一致性**要求，当客户端在Redis的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以Redis满足**可用性**。

Redis保证**最终一致性**，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，但一旦网络恢复，从节点会采用多种策略努力追赶，继续尽力保持和主节点一致。

## 增量同步
Redis同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存buffer中，然后异步将buffer中的指令同步到从节点，从节点一边执行同步的指令流来达到和主节点一样的状态，一边向主节点反馈自己同步到哪里了（偏移量）。

Redis的复制内存buffer是个定长数组，如果内存buffer满了，就会从头覆盖里面的内容。

当网络不好，从节点不能及时和主节点进行同步，当网络恢复时，主节点中很多没有同步的指令在内存buffer中有可能被后续的指令覆盖掉了，这时需要用到**快照同步**。

## 快照同步
快照同步首先需要在主节点上进行一次bgsave，将当前内存的数据全部快照到磁盘文件中，然后再将快照文件的内容全部传送到从节点。

从节点将快照文件接受完毕后，立即执行一次全量加载，加载之前先要将当前内存的数据清空，加载完毕后通知主节点继续进行增量同步。

如果快照同步时间过长，或者复制buffer设置得太小，那么同步期间的增量指令又会被覆盖，那么就又会发起快照同步，造成快照同步的死循环。

所以需要配置一个合适的复制buffer大小参数，避免快照同步的死循环。同样单个Redis的内存不宜设置过大，设置过大就会导致rdb文件过大。

## 增加从节点
当从节点增加到集群中时，需要先进行一次全量的快照同步，同步完成后再进行增量同步。
所以单个Redis的内存不宜过大，内存太大会导致 rdb 文件过大，主从全量同步延迟太长，然后会造成快照同步的死循环。

## 无盘复制


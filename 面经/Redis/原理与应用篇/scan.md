# Scan
keys命令可以列出所有满足特定正则字符串规则的key,有两个缺点：
- 返回的命令太多，没有参数可以控制，比如offset/limit参数
- keys算法是遍历算法，复杂度为O(n),在查询过程中会造成其他指令等待。

scan相比keys有以下特点：
- 复杂度虽然也是O(n),但是它通过游标分布进行的，不会阻塞线程。
- 提供limit参数，可以控制每次返回结果的最大条数，limit只是一个hint,返回的结果可多可少.
- 同keys一样，它也提供模式匹配功能
- 服务器不需要为游标保存状态，游标的唯一状态就是scan返回给客户端的游标整数。
- 返回的结果可能会有重复，需要客户端去重，这点非常重要。
- 遍历过程中如果有数据修改，改动后的数据能不能遍历到是不确定的
- 单次返回的结果是空的并不意味着遍历结束，而要看返回的游标值是否为零。

## scan基本用法
scan提供了三个参数，第一个是cursor整数值，第二个是key的正则模式，第三个是遍历的limit hint.第一次遍历时，设置cursor的位置为0，然后将返回结果中的第一个整数值作为下一次遍历的cursor,一直遍历到返回的cursor值为0时结束。

```java
127.0.0.1:6379> scan 0 match key99* count 1000         //从cursor为0开始，匹配key99*的，遍历1000条左右
1) "9089"                                    //返回cursor位置
2) 1) "key9975"
   2) "key9949"
   3) "key992"
   4) "key9906"
   5) "key990"
   6) "key9956"
   7) "key998"
   8) "key994"
   9) "key9955"
127.0.0.1:6379> scan 9089 match key99* count 1000            //以之前返回的游标位置继续遍历
1) "13145"
2)  1) "key9918"
    2) "key9940"
    3) "key9987"
    4) "key991"
    5) "key9916"
    6) "key9929"
    7) "key9981"
    8) "key9942"
    9) "key9912"
   10) "key9948"
   11) "key9914"
   12) "key9938"
   13) "key993"
..........
127.0.0.1:6379> scan 16383 match key99* count 1000              //当返回cursor为0,说明遍历一遍，结束
1) "0"
2) (empty list or set)
```

## scan遍历顺序
scan遍历顺序非常特别，它不是从第一维数组的第0位一直遍历到末尾，而是采用了高位进位加法来遍历。使用这样的遍历方式，是考虑到字典的扩容和缩容时避免槽位的遍历重复和遗漏。

字典扩容后高位会出现新的槽位，如果是普通的遍历方式，则会遗漏掉高位的槽位，因为不管是扩容还是缩容，当前槽位值都会与低位的相同，所以先高后低就会在缩容或者扩容时误认为已经遍历过高位。

## 更多的scan指令
scan是一系列指令，还可以对指定的容器集合进行遍历，比如zscan遍历zset集合元素，hscan遍历hash字典元素。sscan遍历set集合的元素。

## 大key扫描
如果在Redis中形成了很大的对象，如很大的hash或者很大的zset。在进行迁移的时候，扩容的时候，以及删除的时候都会造成Redis卡顿。所以需要尽量避免大Key的发生。

定位大Key:
```java
redis-cli -h 127.0.0.1 -p 7001 --bigkeys
```
以下指令每隔100条scan指令就会休眠0.1s,ops就不会剧烈抬升，但是扫描的时间会很长。
```java
redis-cli -h 1270.0.1 -p 7001 --bigkeys -i 0.1
```

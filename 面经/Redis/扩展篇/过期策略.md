# 过期策略

## 场景
同一时间过期的key过多，占用Redis的处理时间

## 过期的KEY集合
Redis会将每个设置了过期时间的key放入一个独立的字典中，以后会定时遍历这个字典来删除到期的key.

除了定时遍历之外，它还会使用惰性策略来删除过期的key。惰性策略就是在客户端访问这个key的时候，Redis对key的过期时间进行检查，如果过期了就立即删除。如果说定时删除是集中处理，那么惰性删除就是零散处理。

## 定时扫描策略
Redis默认每秒进行10次过期扫描，过期扫描不会遍历过期字典中所有的key,而是采用了一种简单的贪心策略，步骤如下：
- 从过期字典中随机选出20个key.
- 删除这20个key中已经过期的key.
- 如果过期的key的比例超过1/4,那就重复步骤（1）

为了保证过期扫描不会出现循环过度，导致线程卡死的现象，算法还增加了扫描时间的上限，默认不会超过25ms.

## 所有Key同时过期会出现什么，怎么解决？
内部情况：

Redis会持续扫描过期字典，直到过期字典中过期的key变得稀疏，从上面来看是达到1/4,才会停止。这就会导致线上读写请求出现明显的卡顿现象。导致这种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的CPU消耗。

现象：

当客户端请求到来时，服务器正好进入过期扫描状态，客户端的请求将会等待至少25ms后才会处理，如果客户端将超时时间设置得比较短，比如10ms，那么就会出现大量的链接因为超时而关闭。

解决：

业务开发人员给过期时间设置一个随机范围，而不能全部在同一时间过期。

```java
# 在目标过期时间上增加一天的随机时间
redis.expire_at(key, random_randint(86400) + expire_ts)
```


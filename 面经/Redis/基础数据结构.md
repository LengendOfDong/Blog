# 基础数据结构
Redis有5种基础数据结构，分别为：string(字符串），list(列表），hash(字典），set(集合），zset(有序集合）

- string

  Redis的字符串是动态字符串，可以修改的字符串，内部结构实现类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。
  当字符串长度小于1MB时，扩容都是加倍现有的空间，当字符串长度超过1MB时，每次扩容都是扩容1MB空间。
  字符串最大的长度为512MB。
  
  可以进行键值对:
  ```java
  127.0.0.1:6379> set name codehole
  OK
  127.0.0.1:6379> get name
  "codehole"
  127.0.0.1:6379> exists name
  (integer) 1
  127.0.0.1:6379> del name
  (integer) 1
  127.0.0.1:6379> get name
  (nil)
  ```
  
  批量键值对:
  ```java
  127.0.0.1:6379> set name1 codehole
  OK
  127.0.0.1:6379> set name2 holycoder
  OK
  127.0.0.1:6379> mget name1 name2
  1) "codehole"
  2) "holycoder"
  127.0.0.1:6379> mget name1 name2 name3
  1) "codehole"
  2) "holycoder"
  3) (nil)
  127.0.0.1:6379> mset name1 boy name2 girl name3 unknown
  OK
  127.0.0.1:6379> mget name1 name2 name3
  1) "boy"
  2) "girl"
  3) "unknown"
  ```
  
  过期和set命令扩展：
  ```java
  127.0.0.1:6379> set name codehole
  OK
  127.0.0.1:6379> get name
  "codehole"
  127.0.0.1:6379> expire name 5   // 5s后过期
  (integer) 1
  127.0.0.1:6379> get name
  "codehole"
  127.0.0.1:6379> get name
  "codehole"
  127.0.0.1:6379> get name
  (nil)
  127.0.0.1:6379> setex name 5 codehole  // setex = set + expire
  OK
  127.0.0.1:6379> get name
  "codehole"
  127.0.0.1:6379> get name
  "codehole"
  127.0.0.1:6379> get name
  (nil)
  127.0.0.1:6379> setnx name codehole   //setnx = set + not exists
  (integer) 1
  127.0.0.1:6379> get name
  "codehole"
  127.0.0.1:6379> set name codehole
  OK
  127.0.0.1:6379> setnx name codehole
  (integer) 0
  ```
  
  计数：
  ```java
  127.0.0.1:6379> set age 30
  OK
  127.0.0.1:6379> incr age
  (integer) 31
  127.0.0.1:6379> incrby age 5
  (integer) 36
  127.0.0.1:6379> incrby age -5
  (integer) 31
  127.0.0.1:6379> set codehole 9223372036854775807
  OK
  127.0.0.1:6379> incr codehole
  (error) ERR increment or decrement would overflow
  ```
  
- list

  Redis的列表相当于Java中的LinkedList，是链表而不是数组。
  
  - 右边进左边出：队列
    
  队列是先进先出的数据结构，常用于消息排队和异步逻辑处理，它会确保元素的访问顺序性。rpush(右边进)，lpop(左边出)
  
  - 右边进右边出：栈
  
  栈是先进后出的数据结构，跟队列正好相反。rpush(右边进),rpop(右边出）
  
  在列表元素较少的情况下，会使用一块连续的内存存储，这个结构是ziplist,即压缩列表。分配的是一块连续的内存。当列表元素比较多的时候才会改成quicklist。
  
  Redis将链表和ziplist结合起来组成了quicklist,也就是将多个ziplist使用双指针的方式连接，这样不仅减少了内存碎片的产生，也可以满足快速插入删除性能。
  
- hash

  Redis的字典相当于java中的HashMap。实现结构上与Java的HashMap也是一样的，使用的是“数组 + 链表”的二维结构。
  
  Redis为了追求高性能，不能阻塞服务，所以采用了渐进式rehash策略。
  
  渐进式rehash会在rehash的同时，保留新旧两个hash结构，查询时会同时查询两个hash结构，然后在后续的定时任务以及hash操作指令中，循序渐进地将旧hash的内容一点点地迁移到新hash结构中。当迁移完成后，就会使用新的hash结构取而代之。当hash移除了最后一个元素之后，该数据结构被自动删除，内存被回收。
  
  

## 选择优化的数据类型
- 更小的通常更好
  - 通常情况下，应该尽量使用可以正确存储数据的最小数据类型。更下的数据类型通常更快，因为它们占用更少的磁盘，内存和CPU缓存，并且处理时需要的CPU周期也更少。
  
- 简单就好
  - 简单数据类型的操作通常需要更少的CPU周期。两个例子：一个是应该用MySQL内建的类型，而不是字符串来存储日期和时间。另外一个就是应该用整型来存储IP地址。
 
- 尽量避免NULL
  - 很多表都包含可为NULL（空值）的列。通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间。
  
为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等。第二步是选择具体类型。

DATETIME和TIMESTAMP列都可以存储相同类型的数据：时间和日期，精确到秒。然而TIMESTAMP只使用DATETIME一般的存储空间，并且会根据时区变化，具有特殊的自动更新能力。另一方面，TIMESTAMP允许的时间范围要小得多，有时候它的特殊能力会成为障碍。

### 整数类型
有两种类型的数字：整数和实数。

如果存储整数，可以使用的整数类型：TINYINT/SMALLINT/MEDIUMINT/INT/BIGINT。分别使用8，16，24，32，64位存储空间。

整数类型有可选的UNSIGNED属性，表示不允许负值，比如TINYINT UNSIGNED的取值范围为0~255，而TINYINT的取值范围为-128~127。

有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据实际情况选择合适的类型。

### 实数类型
实数是带有小数部分的数字。MySQL既支持精确类型，也支持不精确类型。

因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算的时候才使用DECIMAL。但在数据量大的时候，可以考虑使用BIGINT代替DECIMAL。假设要存储财务数据精确到万分之一，则可以把所有金额乘以一百万，然后将结果存储到BIGINT里，这样可以避免浮点存储计算不精确和DECIMAL精确计算代价高的问题。

### 字符串类型
VARCHAR和CHAR是两种最主要的字符串类型。
VARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型，它比定长类型更省空间。

VARCHAR需要额外的空间来记录字符串的长度，如果列的最大长度小于或等于255字节，则只使用1个字节来表示，否则使用2个字节。

VARCHAR的适合情况：字符串的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。

CHAR类型是定长的，当存储CHAR值时，MySQL会删除所有的末尾空格，CHAR值会根据需要采用空格进行填充的方式以方便比较。

CHAR的适合情况：CHAR适合存储很短的字符串，或者所有值都接近同一个长度。定长的CHAR在变更时不容易产生碎片。对于非常短的列，CHAR的效率也比VARCHAR更好。VARCHAR还需要额外的直接进行记录长度。

### BLOB和TEXT类型
BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

它们分别属于两组不同的数据类型家族：字符类型是TINYTEXT,SMALLTEXT,TEXT,MEDIUMTEXT,LONGTEXT,对应的二进制类型是TINYBLOB,SMALLBLOB,BLOB,MEDIUMBLOB,LONGBLOB。BLOB是SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词。

当BLOB和TEXT值太大时，InnoDB会使用专门的"外部“存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。

BLOB和TEXT家族之间仅有的不同是BLOB类型存储的是二进制数据，没有排序规则或字符集，而TEXT类型有字符集和排序规则。

MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length字节而不是整个字符串做排序。

### 使用枚举（ENUM)代替字符串类型
枚举列可以把一些不重复的字符串存储成一个预定义的集合。
枚举字段是按照内部存储的整数而不是定义的字符串来进行排序的。
枚举最不好的地方就是，字符串列表时固定的，添加或删除字符串必须使用ALTER TABLE。对于未来可能改变的字符串，不应该使用枚举。
ENUM列和ENUM列之间关联比ENUM和VARCHAR列关联查询快很多。
转换列为枚举型可以使表的大小缩小1/3。

### 日期和时间类型
DATETIME
    - 这个类型能保存大范围的值，从1001年到9999年，精度为秒。
TIMESTAMP
    - 使用4个字节存储，范围比DATETIME小很多，存储范围为1970年到2038年。TIMESTAMP显示的值依赖于时区。
MySQL提供了FROM_UNIXTIME()函数把UNIX时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数把日期转换为Unix时间戳。
通常应该尽量使用TIMESTAMP，因为它比DATETIME空间效率高。

### 位数据类型
MySQL有少数几种类型使用紧凑的位存储类型。所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。
BIT:存储一个值为b'00111001'(二进制等于57)到BIT(8)的列进行检索，得到的内容是字符码为57的字符串（MySQL把BIT当做字符串类型，而不是数字类型），也就是ASCII码为57的字符”9“，但在数字上下文场景中，得到的是数字57。

也就是说，在MySQL中，默认将BIT识别为字符串类型，所以存入一串数字，默认会是对应的ASCII码的字符，而只有明确是数字的时候，才会将这串数字转换为相应的整数。

使用包装位来保存权限的访问控制列表（ACL）。每个位或者SET元素代表一个值，例如CAN_READ,CAN_WRITE或者CAN_DELETE。如果使用SET列，可以让MySQL在列定义里存储位到值的映射关系；如果使用整数列，则可以在应用代码里存储这个对应关系。

使用SET列时的查询:
```SQL
mysql> create table acl(perms SET('can_read','can_write','can_delete') not null);
mysql> insert into acl(perms) values('can_read,can_delete');
mysql> select perms from acl where FIND_IN_SET('CAN_READ',perms);
```

使用整数来存储：
```SQL
mysql> SET @CAN_READ := 1 <<0 ,
    -> @CAN_WRITE := 1 << 1,
    -> @CAN_DELETE := 1 << 2;
mysql> create table acl2(
    -> perms tinyint unsigned not null default 0
    -> );
# 此处是使用位与的方式，返回所有有CAN_READ的记录，即CAN_READ位为1的记录。
mysql> SELECT PERMS FROM ACL2 WHERE PERMS & @CAN_READ; 
```

### 选择标识符
考虑的几点：
- 选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑MySQL对这种类型怎么执行计算和比较。例如，MySQL在内部使用整数存储ENUM和SET类型，然后在做比较时转换为字符串。
- 要确保在所有关联表中都使用相同的类型，类型之间需要精确匹配，包括像unsigned这样的属性。
- 在可以满足需求值的范围，并预留未来增长空间的前提下，应该选择最小的数据类型。例如，56个民族，最多有56个，所以使用TINYINT就可以。

#### 整数类型
整数通常是标识列最好的选择，因为它们很快而且可以使用AUTO_INCREMENT.
#### ENUM和SET类型
ENUM和SET列适合存储固定信息，例如有序的状态，产品类型，人的性别。
#### 字符串类型
避免使用字符串作为标识列，因为它们很耗费空间，通常比数字类型慢。

## MySQL schema 设计中的陷阱
### 太多的列
 MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。
 
 MyISAM的变长行结构和InnoDB的行结构则总是需要转换，转换的代价依赖于列的数量。
 
 ### 太多的关联
 MySQL限制了每个关联操作最多只能有61张表，但是在61张表的情况下，解析和优化查询的代价也会成为MySQL的问题。
 
 ### 全能的枚举
 在MySQL中，当需要在枚举列表中增加一个新的类型时，就需要执行一次ALTER TABLE操作。
 
 ### 变相的枚举
 枚举列允许在列中存储一组定义值中的单个值，集合列则允许在列中存储一组定义值中的一个或多个值。
 
 ### 非此发明的NULL
 当需要表示未知值的时候，也需要使用NULL。
 
 ## 范式与非范式
 在范式化的数据库中，每个事实数据会出现并且只出现一次，相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。
 
 ### 范式化的优点和缺点
 范式化通常能够带来好处：
 - 范式化的更新操作通常比反范式化要快。
 - 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。
 - 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
 - 很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句。
 
 范式化的缺点：
 - 范式化设计的schema通常需要关联。
 - 可能使索引策略无效，多个列形成的索引，如果这些列存放在不同的表中，则索引无效，但是在一个表中，则索引才会生效。
 
 ### 反范式的优点和缺点
 反范式的好处：
 - 所有数据都在一张表中，可以很好地避免关联。
 
 ### 混用范式化和反范式化
 事实上，在实际应用中经常需要混用，最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。
 
 ## 缓存表和汇总表
 缓存表表示存储那些可以比较简单地从schema其他表获取数据的表，而汇总表是使用GROUP BY语句聚合数据的表。
 
缓存表对优化搜索和检索查询语句很有效。有时需要创建一张只包含主表中部分列的缓存表。

当重建缓存表和汇总表时，通常需要保证数据在操作时依然可用。这就需要通过使用”影子表“来实现，”影子表“指的是一张在真实表”背后“创建的表。当完成了建表操作
 后，可以通过一个原子的重命名操作切换影子表和原表。
 
## 加快ALTER TABLE操作的速度
对常见的场景，能使用的技巧只有两种：一种是先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换；另外一种技巧是”影子拷贝“。

影子拷贝的技巧是用要求的表结构创建一张和源表无关的新表，然后通过重命名和删除操作来交换两张表。

不是所有的ALTER TABLE操作都会引起表重建。所有的MODIFY COLUMN操作都将导致表重建。
```SQL
mysql>ALTER TABLE sakila.film MODIFY COLUMN rental_duration TINYINT(3) NOT NULL DEFAULT 5;
```
另外一种方法时通过ALTER COLUMN操作来改变列的默认值：
```SQL
mysql>ALTER TABLE sakila.film ALTER COLUMN rental_duration SET DEFAULT 5;
```
这个语句会直接修改.frm文件而不涉及表数据，所以这个操作是非常快的。

## 总结
简单的原则：
- 尽量避免过度设计，例如会导致极其复杂查询的schema设计，或者有很多列的表设计。
- 使用小而简单的合适数据类型，除非真实数据模型中有确切需要，否则应该尽可能地避免使用NULL值。
- 尽量使用相同的数据类型存储相似或相关的值，尤其是在关联条件中使用的列。
- 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存。
- 尽量使用整型定义标识列。
- 避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度。
- 小心使用ENUM和SET。虽然它们用起来很方便，但是不要滥用，否则有时候会变成陷阱。最好避免使用BIT。

范式是好的，但是有的时候反范式也是必需的，并且能够带来好处。

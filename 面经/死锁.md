# 必要条件
- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

# 处理方法
主要有四种方法：
- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免

# 鸵鸟策略
当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采取鸵鸟策略。
大多数操作系统，包括Unix,Linux和Windows,处理死锁问题的办法仅仅是忽略它。

# 死锁检测与恢复
## 1.每种类型一个资源的死锁检测
每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

## 2.每种类型多个资源的死锁检测
- A向量：资源剩余量
- C向量：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量
- R矩阵：每个进程请求的资源数量

算法如下：

每个进程最开始都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1.寻找一个没有被标记的进程Pi,它所请求的资源小于等于A。

2.如果找到了这样的一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并返回1

3.如果没有这样一个进程，算法终止

## 3.死锁恢复
- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复

# 死锁预防
在程序运行之前预防发生死锁
- 破坏互斥条件
- 破坏占有和等待条件
- 破坏不可抢占条件
- 破坏环路条件

# 死锁避免
在程序运行时避免发生死锁
## 1.安全状态
## 2.单个资源的银行家算法
## 3.多个资源的银行家算法

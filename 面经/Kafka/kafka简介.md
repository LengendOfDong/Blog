# 消息和批次
消息由字节数组组成的，对于kafka来说，它并没有什么特殊的含义或者意义，消息可以有一个可选的元数据，也就是键。当消息以一种可控的方式写入不同的分区时，会用到键。最简单的例子就是为键生成一个一致性散列值，然后使用散列值对主题分区进行取模，为消息选取分区。这样可以保证具有相同键的消息总是被写到相同的分区上。

为了提高效率，消息被分批次写入Kafka。批次就是一组消息，需要在时间延迟和吞吐量之间进行权衡。如果累积的消息越多，一个批次的消息也就越多，需要更多的时间进行处理，同时吞吐量也会下降，但是会降低网络开销。如果每一个消息都单独穿行于网络，会导致大量的网络开销。

# 主题和分区
kafka的消息通过主题进行分类。主题可以被分为若干个分区，一个分区就是一个提交日志。消息以追加的方式写入分区，然后以先入先出的顺序进行读取。

由于一个主题包含几个分区，因此无法在整个主题范围内保证消息的顺序，但是可以保证消息在单个分区内的顺序。

# 生产者与消费者
Kafka的客户端就是Kafka系统的用户，它们被分为两种基本类型，生产者和消费者。

生产者创建消息，在其他发布与订阅系统中，生产者可能被称为发布者或者写入者。一般情况下，消息会被发布到一个特定的主题上。生产者在默认情况下把消息均衡地分布到主题的所有分区上。在某些情况下，生产者会把消息直接写到指定的分区上，通过为消息的键生成一个散列值，再对分区数进行取模，再发布到特定的分区上，这样对于具有相同键的消息就可以发布到同一个分区上。生产者也可以使用自定义的分区器，根据不同的业务规则将消息映射到分区。

消费者读取消息，在其他发布与订阅系统中，消费者可能被称为订阅者或者读者。偏移量是另一种元数据，它是一个不断递增的整数值，在创建消息时，Kafka会把它添加到消息里。

消费者把每个分区最后读取的消息偏移量保存在zookeeper或者kafka上，这样如果消费者关闭或者重启，它的读取状态不会消失。

消费者是消费者群组的一部分，也就是说，会有一个或者多个消费者共同读取一个主题，群组保证每个分区只能有一个消费者使用。消费者数量必然是小于等于主题中的分区数的。消费者与分区之间的映射通常被称为消费者对分区的**所有权关系**。

# broker和集群
一个独立的Kafka服务器被称为broker。broker接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。

broker是集群的组成部分，每个集群都有一个broker同时充当了**集群控制器**的角色。在集群中，一个分区从属于一个broker，该broker被称为分区的**首领**。一个分区可被分配给多个broker，这个时候会发生分区复制。这种复制机制为分区提供了消息冗余，如果有一个broker失效，其他broker可以接管领导权。

**保留消息**是kafka的一个重要特性，Kafka broker默认的消息保留策略是这样的，要么保留一段时间（比如7天），要么保留到消息达到一定大小的字节数。（比如1GB）当消息数量达到这些上限时，旧消息就会被删除。所以在任何时刻，可用消息的总量都不会超过配置参数指定的大小。

# 多集群
使用多集群有几点原因：
- 数据类型分离
- 安全需求隔离
- 多数据中心（灾难恢复）

# kafka的优势
## 多个生产者
kafka可以无缝地支持多个生产者，很适合用来从多个前端系统收集数据，并以统一的格式对外提供数据。

## 多个消费者
Kafka也支持多个消费者从一个单独的消息流上读取数据，而且消费者之间互不影响。多个消费者可以组成一个群组，他们共享一个消息流，并保证整个群组对每个给定的消息只处理一次。

例如一个消费群组中每个消费者都有不同的职责，每个消费者都订阅不同的主题进行消费，这样就可以实现并行处理多个任务。

## 基于磁盘的数据存储
消息被提交到磁盘，根据设置的保留规则进行保存。消费者可能由于处理速度慢或者突发的流量高峰导致无法及时读取消息，而持久化数据可以保证数据不会丢失。消费者可以从上次中断的地方继续处理消息。

## 伸缩性
一个包含多个broker的集群，即使个别broker失效，仍然可以持续地为客户提供服务。要提高集群的容错能力，需要配置较高的复制系数。

## 高性能
通过横向扩展生产者、消费者和broker，Kafka可以轻松处理巨大的消息流。在处理大量数据的同时，还可以保证亚秒级的消息延迟。

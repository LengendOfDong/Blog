# zookeeper的实现
zookeeper通过Master选举来帮助分布式系统解决单点故障，保证该系统中每时每刻只有一个Master为分布式系统提供服务。

zookeeper如果只用一台服务器来提供服务，那么这台服务器挂了，就会出现问题，此时需要zookeeper在其实现过程中需要做一些可用性和恢复性的保证。

## zookeeper运行模式
zookeeper服务有两种不同的运行模式，一种是“独立模式”（standalone mode)，即只有一个zookeeper服务器，这种模式较为简单，比较适合于测试环境，甚至可以在单元测试中采用，但是不能保证高可用性和恢复性。在生产环境中的zookeeper通常以“复制模式”（replicated mode)运行于一个计算机集群上，这个计算机集群被称为一个“集合体“（ensemble)

zooKeeper通过复制来实现高可用性，只要集合体中超过半数以上的机器处于可用状态，它就可以提供服务。例如，在一个有5个节点的集合体中，每个follower节点的数据都是leader节点数据的副本，也就是说我们的每个节点的数据都是一样的，这样就可以有五个节点提供zookeeper服务。并且集合体中任意两台机器出现故障，都可以保证服务继续，因为剩下的3台机器超过了半数。

注意，6个节点的集合体也只能够容忍2台机器出现故障，因为如果3台机器出现故障，剩下的3台机器没有超过集合体的半数。出于这个原因，一个集合体通常包含奇数台机器。

从概念上来说，ZooKeeper它所做的就是确保对Znode树的每一个修改都会被复制到集合体中超过半数的机器上。如果少于半数的机器出现故障，则最少有一台机器会保存最新的状态，那么这台机器就是我们的Leader。其余的副本最终也会更新到这个状态。如果 Leader挂了，由于其他机器保存了Leader的副本，那就可以从中选出一台机器作为新的Leader继续提供服务。

## zookeeper的读写机制
1）概述

zookeeper的核心思想是，提供一个非锁机制的Wait Free的用于分布式系统同步的核心服务，提供简单的文件创建、读写操作接口，其系统核心本身对文件读写并不提供加锁互斥的服务，但是提供基于版本比对的更新操作，客户端可以基于此自己实现加锁逻辑。

2） zk集群服务
zk集群中每个server，都保存一份数据副本，zookeeper使用简单的同步策略，通过以下两条基本保证来实现数据的一致性：
- 全局串行化所有的写操作
- 保证同一客户端的指令被FIFO执行（以及消息通知的FIFO）
所有的读请求由zk server本地响应，所有的更新请求将转发给Leader，由Leader实施。

3）zk组件
zk组件，除了请求处理器（Request Processor）以外，组成ZK服务的每一个Server会复制这些组件的副本。

ReplicatedDatabase是一个内存数据库，它包含了整个Data Tree。为了恢复，更新会被记录到磁盘，并且写在被应用到内存数据库之前，先被序列化到磁盘。
每一个ZK Server，可服务于多个Client。Client可以连接到一台Server，来提交请求。读请求，由每台Server数据库的本地副本来进行服务。改变服务器的状态的写请求，需要通过一致性协议来处理。

作为一致性协议的一部分，来自Client的所有写请求，都要被转发到一个单独的Server，称作Leader。ZK集群中其他Server 称作Follower，负责接收Leader发来的提议消息，并且对消息转发达成一致。消息层处理leader失效，同步Followers和Leader。

ZooKeeper使用自定义的原子性消息协议。由于消息传送层是原子性的，ZooKeeper能够保证本地副本不产生分歧。当leader收到一个写请求，它会计算出当写操作完成后系统将会是什么状态，接着将之转变为一个捕获状态的事务。

4）zk性能
ZooKeeper被应用程序广泛使用，并有数以千计 的客户端同时的访问它，所以我们需要高吞吐量。我们为ZooKeeper 设计的工作负载的读写比例是 2：1以上。然而我们发现，ZooKeeper的高写入吞吐量，也允许它被用于一些写占主导的工作负载。ZooKeeper通过每台Server上的本地 ZK的状态副本，来提供高读取吞吐量。因此，容错性和读吞吐量是以添加到该服务的服务器数量为尺度。写吞吐量并不以添加到该服务的机器数量为尺度。

# zookeeper的保证
ZooKeeper服务的高可用性就需要采用分布式模式，来冗余数据写多份，写多份带来一致性问题，一致性问题又会带来性能问题，那么就此陷入了无解的死循环。

## CAP理论
分布式领域存在CAP理论：
- C：Consistency，一致性，数据一致更新，所有数据变动都是同步的。
- A：Availability，可用性，系统具有好的响应性能。
- P ：Partition tolerance，分区容错性。以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择，也就是说无论任何消息丢失，系统都可用。

该理论已被证明：任何分布式系统只可同时满足两点，无法三者兼顾。 因此，将精力浪费在思考如何设计能满足三者的完美系统上是愚钝的，应该根据应用场景进行适当取舍。

一致性分类：

一致性是指从系统外部读取系统内部的数据时，在一定约束条件下相同，即数据变动在系统内部各节点应该时同步的。根据一致性的强弱程度不同，可以将一致性级别分为如下几种：
- 强一致性：任何时刻，任何用户都能读到最近一次成功更新的数据。
- 单调一致性：任何时刻，任何用户一旦读到某个数据在某次更新后的值。那么就不会再读取到比这个更旧的值。也就是说，可获取的数据顺序必是单调递增的。
- 会话一致性。任何用户在某次会话中，一旦读到某个数据在某次更新后的值，那么在本次会话中就不会再读到比这个更旧的值。会话一致性是在单调一致性的基础上进一步放松约束，只保证单个用户单个会话的单调性，在不同的用户或者同一用户不同会话间则没有保障。
- 最终一致性：用户只能读取到某次更新后的值，但系统保证数据将最终达到完全一致的状态，只是所需时间不能保障。
- 弱一致性：用户无法在确定时间内读到最新更新的值。


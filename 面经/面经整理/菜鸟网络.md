# notify和notifyAll的区别是什么
当你调用notify时，只有一个等待线程会被唤醒而且它不能保证哪个线程会被唤醒，这取决于线程调度器。

当你调用notifyAll时，等待该锁的所有线程都会被唤醒

```java
/**
     * Wakes up a single thread that is waiting on this object's
     唤醒在该对象监视器上等待的一个单一线程
     * monitor. If any threads are waiting on this object, one of them
     如果有许多线程都在这个对象监视器上等待，那么其中一个将会被唤醒
     * is chosen to be awakened. The choice is arbitrary and occurs at
      唤醒线程的选择是随机的，这取决于线程调度器的实现。
     * the discretion of the implementation. A thread waits on an object's
     线程通过调用wait方法之一来等待对象监视器
     * monitor by calling one of the {@code wait} methods.
     * <p>
     * The awakened thread will not be able to proceed until the current
      被唤醒线程将不能继续进行直到当前线程的放弃在这个对象上的锁。
     * thread relinquishes the lock on this object. The awakened thread will
      被唤醒线程将以惯用的方式和其他被激活的同步线程竞争
     * compete in the usual manner with any other threads that might be
     * actively competing to synchronize on this object; for example, the
      例如，被激活的线程成为下一个锁定这个对象的线程将会变得不可靠
     * awakened thread enjoys no reliable privilege or disadvantage in being
     * the next thread to lock this object.
     * <p>
     * This method should only be called by a thread that is the owner
     这个方法应该仅被这个对象监视器的拥有线程来调用
     * of this object's monitor. A thread becomes the owner of the
     线程通过三种方式来成为对象监视器的拥有者：
     * object's monitor in one of three ways:
     * <ul>
     * <li>By executing a synchronized instance method of that object.
     通过执行对象的同步执行方法
     * <li>By executing the body of a {@code synchronized} statement
     *     that synchronizes on the object.
     通过执行同步对象的语句体
     * <li>For objects of type {@code Class,} by executing a
     *     synchronized static method of that class.
     通过执行那个类的同步静态方法
     * </ul>
     * <p>
     * Only one thread at a time can own an object's monitor.
     仅有一条线程能够每次能够拥有一个对象的监视器
     *
     * @throws  IllegalMonitorStateException  if the current thread is not
     *               the owner of this object's monitor.
     * @see        java.lang.Object#notifyAll()
     * @see        java.lang.Object#wait()
     */
    public final native void notify();
  
/**
     * Wakes up all threads that are waiting on this object's monitor. A
     唤醒在对象监视器上等待的所有线程
     * thread waits on an object's monitor by calling one of the
     通过调用一个wait方法来等待对象监视器
     * {@code wait} methods.
     * <p>
     * The awakened threads will not be able to proceed until the current
     * thread relinquishes the lock on this object. The awakened threads
     * will compete in the usual manner with any other threads that might
     * be actively competing to synchronize on this object; for example,
     * the awakened threads enjoy no reliable privilege or disadvantage in
     * being the next thread to lock this object.
     * <p>
     * This method should only be called by a thread that is the owner
     * of this object's monitor. See the {@code notify} method for a
     * description of the ways in which a thread can become the owner of
     * a monitor.
     *
     * @throws  IllegalMonitorStateException  if the current thread is not
     *               the owner of this object's monitor.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#wait()
     */
      public final native void notifyAll();
```

# 为什么总是在循环内调用wait()

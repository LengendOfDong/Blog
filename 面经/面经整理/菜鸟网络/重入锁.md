# ReentrantLock和Synchronized的异同

## 相同点
两者都是可重入锁，两者都是同一个线程每进入一次，计数器加1， 等到计数器变为0时才释放锁。都是在用户态把加锁问题解决，避免进入内核造成阻塞，在synchronized引入轻量锁，偏向锁之后，两者的性能差不多，官方推荐使用synchronized.

## 不同点
ReentrantLock是jdk实现的，synchronized是jvm实现的，ReentrantLock需要手动释放锁，synchronized是由编译器自动释放，


## 重入锁的原理
每个锁关联一个线程持有者和计数器，当计数器为0时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法。当某一线程请求成功后，JVM会记下锁的持有线程，并将计数器置为1，此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出同步代码时，计数器会递减，如果计数器为0，则释放该锁。


## 概述

程序计数器、虚拟机栈、本地方法栈在类结构确定下来时就是已知的，这几个区域的内存分配和回收都具有确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就回收了。

Java堆和方法区有着不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有在运行期间，我们才知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。

## 对象已死？

### 引用计数法

在Java领域，主流的Java虚拟机都没有选用引用计数法来管理内存，主要是因为这个算法有很多例外情况需要考虑，比如引用计数很难解决对象之间相互循环引用的问题。

### 可达性分析算法

可达性分析算法的基本思路：通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程中所走过的路径称为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

固定可作为GC Roots对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等
- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
- 在方法区中常量引用的对象，譬如字符串常量池里的引用
- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException/OutOfMemoryError）等，还有系统类加载器
- 所有被同步锁（synchronized关键字）持有的对象
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

### 再谈引用

有一类对象：当内存足够时，能保留在内存之中，如果内存空间在进行垃圾收集后仍然非常紧张，就可以抛弃这些对象。

引用分为以下几种：

- 强引用：程序代码之中普遍存在的引用赋值，无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象
- 软引用（内存溢出前回收）：用来描述一些还有用、但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
- 弱引用（垃圾收集时回收）：用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止，当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用：虚引用也被称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。

虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

使用场景：
　　jdk中直接内存的回收就用到虚引用，由于jvm自动内存管理的范围是堆内存，而直接内存是在堆内存之外，所以直接内存的分配和回收都是有Unsafe类去操作，java在申请一块直接内存之后，会在堆内存分配一个对象保存这个堆外内存的引用，这个对象被垃圾收集器管理，一旦这个对象被回收，相应的用户线程会收到通知并对直接内存进行清理工作。

### 生存还是死亡？

两次标记：

- 可达性分析后发现没有与GC Roots相连接的引用链，那么它会被标记第一次
- 没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么会被标记第二次

finalize方法是对象不被回收的最后一次机会，如果将对象绑定引用链上的任意一个对象，那么就会移出回收集合。如果已经被调用一次之后，再次被调用，则不会再给机会，直接移到回收集合中。

finalize方法已被官方声明为不推荐使用的语法，建议直接忘掉这个语法。：）

### 回收方法区

方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。

判断字符串常量是否废弃（包括其他类接口、方法、字段的符号引用等）：

没有任何字符串对象引用常量池中的常量

判断一个类型是否废弃，同时满足以下三个条件：

- 该类所有的实例都已经被回收，也就是java堆中不存在该类及其任何派生子类的实例
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

Hotspot虚拟机提供了-Xnoclassgc参数进行控制，是否要对类型进行回收。

### 垃圾收集算法

垃圾收集算法分为：引用计数式垃圾收集和追踪式垃圾收集。

由于主流的Java虚拟机都没有涉及引用计数式垃圾收集，所以主要是追踪式垃圾收集。

#### 分代收集理论

垃圾收集器的设计原则：收集器应该将Java堆划分成不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。

在新生代上建立一个全局的数据结构，该结构被称为“记忆集”，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。这样在发生Minor GC时，只针对存在跨代引用的对象才会被加入到GC Roots进行扫描。这种方法相对于扫描整个老年代来说，是划算很多的。

针对不同分代的收集名称，定义如下：

- 部分收集（Partial GC）:指目标不是完整收集整个Java堆的垃圾收集
  - 新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集
  - 老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
  - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集

#### 标记-清除算法

标记清除算法就是分为“标记”和“清除”两个阶段。要么标记出需要回收的对象，然后统一回收被标记的对象；要么标记出存活的对象，统一回收未被标记的对象。

标记-清除算法有两个缺点：

1. 执行效率不稳定，当出现大量需要回收的对象时，就需要执行大量的标记和清除动作，随着数据量增加，执行效率会降低。
2. 内存空间的碎片化问题：标记-清除会产生大量不连续的内存碎片，当需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#### 标记-复制算法

半区复制：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当一块的内存用完了，就将还存活的对象复制到另外一块上面。

半区复制的缺陷：将可用内存缩小为原来的一半，空间浪费严重。

Appel回收：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor空间。发生垃圾收集时，将Eden空间和Survivor空间依然存活的对象都放到另一块Survivor空间中。

Eden空间和Survivor空间的大小比例为8:1，只会浪费10%的新生代空间。如果出现存活的对象超过了10%的新生代，Appel式回收可以依赖其他内存区域（大多数是老年代）进行分配担保。

标记-复制算法的缺点：当对象存活率较高时要进行大量的复制操作，效率会降低。

#### 标记-整理算法

标记-整理算法和标记-清除算法类似，后续步骤不是直接对可回收对象进行整理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

标记-整理算法是一种移动式的回收算法，而标记-清除算法是一种非移动式的回收算法。

如果移动的话，内存回收时会更复杂。如果不移动的话，内存分配时会更复杂。

总的来说，从整个程序的吞吐量来看，移动对象会更加划算，Hotspot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的。



### HotSpot的算法细节实现

#### 根节点枚举

目前所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。原因是在分析过程中要保证对象引用关系是不可变的，这样分析出来的结果才准确。

### 经典垃圾收集器

#### Serial收集器

Serial收集器强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到收集结束。

Serial收集器依然是Hotspot虚拟机运行在客户端模式下的默认新生代收集器，它简单而高效，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的。

Serial收集器在新生代采取标记-复制算法暂停所有用户线程，在老年代采取标记-整理算法暂停用户所有线程。

#### ParNew收集器

ParNew收集器实质上是Serial收集器的多线程并行版本。

ParNew收集器在新生代采取标记-复制算法暂停所有用户线程，在老年代采取标记-整理算法暂停用户所有线程。

ParNew收集器是不少运行在服务端模式下的Hotspot虚拟机首选的新生代收集器，一个很重要的原因就是：除了Serial收集器外，只有它能与CMS收集器配合工作。

ParNew是Hotspot虚拟机中第一个退出历史舞台的垃圾收集器。

#### Parallel Scavenge收集器

Parallel收集器的关注点和其他收集器不太一样，它的关注点是达到一个可控制的吞吐量。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。

Parallel收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。

垃圾收集停顿时间是以牺牲吞吐量和新生代空间为代价换取的。

由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”，另外收集器还有一个参数-XX:+UseAdaptiveSizePolicy，该开关打开后，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整以提供最合适的停顿时间或者最大的吞吐量。

#### Serial Old收集器

Serial Old收集器是Serial收集器的老年代版本，同样是一个单线程的收集器，使用**标记-整理算法**。

#### Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。

在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

#### CMS收集器

CMS收集器是一种以获取最短回收停顿时间为目标的收集器。从名称就可以看出CMS收集器是以标记-清除算法实现的，它的运作过程分为四个步骤：

- 初始标记
- 并发标记
- 重新标记
- 并发清除


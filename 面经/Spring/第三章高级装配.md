# Spring Profile
每个profile定义一个xml文件，也可以所有profile定义到一个xml文件中。

除了所有的bean定义到了同一个XML文件之中，这种配置方式与定义在单独的XML文件中的实际效果是一样的。

## 激活profile
如果设置了spring.profiles.active的属性的话，那么Spring会优先使用它定义的值

如果没有设置Spring.profiles.active的属性，而设置了Spring.profiles.default的属性的话，那就使用后者的值

如果两者都没有设置的话，那就没有激活的profile

有多种方式来设置这两个属性：
- 作为DispatcherServlet的初始化参数
- 作为Web应用的上下文参数。
- 作为JNDI条目
- 作为环境变量
- 作为JVM的系统属性
- 在集成测试类上，使用@ActiveProfiles注解设置

Spring.profiles.default设置为dev后，开发人员就无需再配置，QA生产或其他环境之中，可通过系统属性，环境变量或JNDI设置Spring.profiles.active设置。

# 条件化的bean
在以下几个场景下，用@Conditional注解很合适：
- 一个或多个bean只有在应用的类路径下包含特定的库时才创建
- 希望某个bean只有当另外某个特定的bean也声明了之后才会创建。
- 只有某个特定的环境变量设置之后，才会创建某个bean

设置@Conditional的类可以是任意实现了Condition接口的类型，只需实现接口提供的matches()方法即可。如果match()方法返回true,那么就会创建带有@Conditional注解的bean,否则，不创建。

```java
@Bean
@Conditional(MagicExistsCondition.class)
public MagicBean magicBean(){
  return new MagicBean();
}
```

在Condition中检查是否存在magic属性，实现Condition接口的matches()方法
```java
public class MagicExistsCondition implements Condition {
    @Override
    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) {
        Environment env = conditionContext.getEnvironment();
        return env.containsProperty("magic");
    }
}
```


# 原创：并发编程学习笔记（七）------ 顺序一致性

注明：<br/>
参考书作者：方腾飞 魏鹏 程晓明<br/>
参考书目：《Java 并发编程的艺术》

# 顺序一致性

  顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型会以顺序一致性内存模型作为参考。

## 数据竞争与顺序一致性

  如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。JMM对正确同步的多线程程序的内存一致性做了如下保证。<br/>
  如果程序是正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与程序在顺序一致性内存模型中的执行结果相同。这里的同步是指广义上的同步，包括对常用同步原语（Synchronized,volatile和final）的正确使用。

## 顺序一致性内存模型

  顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证。顺序一致性内存模型有两大特性。<br/>
1）一个线程中的所有操作必须按照程序的顺序来执行<br/>
2）（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。<br/>
顺序一致性内存模型为程序员提供的视图如下图：<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190721095126713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nZG9uZzEyMzQ1,size_16,color_FFFFFF,t_70"/><br/>
在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。从上面的示意图可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化（即在顺序一致性模型中，所有操作之间具有全序关系）<br/>
  假设有两个线程A和B并发执行。其中A线程有3个操作，它们在程序中的顺序是：A1 -&gt; A2 -&gt; A3。B线程也有3个操作，它们在程序中的顺序是：B1 -&gt; B2 -&gt; B3。<br/>
  假设这两个线程使用监视器锁来正确同步：A线程的3个操作执行后释放监视器锁，随后B线程获取同一个监视器锁。那么程序在顺序一致性模型中的执行效果如下图：<br/>
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190721100707161.png?"/><br/>
  假设两个线程没有做同步，则下面是这个未同步程序在顺序一致性模型中的执行示意图：<br/>
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190721100815621.png?"/><br/>
  未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程A和B看到的执行顺序都是：B1 -&gt; A1 -&gt; A2 -&gt; B2 -&gt; A3 -&gt; B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。<br/>
  但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见。这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。

## 同步线程的顺序一致性效果

  下面看示例代码：

```
class SynchronizedExample{
   int a = 0;
   boolean flag = false;
   public synchronized void writer(){             //获取锁
   	a = 1;
   	flag = true;	
   }                                              //释放锁
   public synchronized void reader(){             // 获取锁
   	if (flag){
   		int i = a;
   		......
   	}
   }                                             //释放锁
}

```

在上面的代码中，假设A线程执行writer()方法后，B线程执行reader()方法。这是一个正确同步的多线程程序。根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：<br/>
<img alt="在这里插入图片描述" src="https://img-blog.csdnimg.cn/20190721105854819.png?"/><br/>
  顺序一致性模型中，所有操作完全按程序的顺序串行执行。而在JMM中，临界区内的代码可以重排序（JMM不允许临界区内的代码跑到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。虽然线程A在临界区内做了重排序，但由于监视器互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。<br/>
  从这里可以看到，JMM在具体实现上的基本方针为：在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门。

## 未同步程序的执行特性

  对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null,False）,JMM保证线程读操作读取到的值不会无中生有（Out Of Thin Air）的冒出来。为了实现最小安全性，JVM在对上分配对象时，首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在已清零的内存空间分配对象时，域的默认初始化已经完成了。<br/>
  在多线程程序中，又想要性能，又想要执行结果同顺序模型一致，是不太可能的。为了保持执行结果一致，就需要做同步处理，这时候免不了要牺牲性能，因为处理器和编译器的优化受到了禁止。<br/>
  未同步程序在JMM中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有如下几个差异：

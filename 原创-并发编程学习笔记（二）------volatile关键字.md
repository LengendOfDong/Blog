# 原创：并发编程学习笔记（二）------volatile关键字

注明：<br/>
参考书作者：方腾飞 魏鹏 程晓明<br/>
参考书目：《Java 并发编程的艺术》

# volatile关键字

在了解volatile关键字之前，先了解一些cpu的术语定义，来给volatile铺路

|术语<th align="center">英文单词</th>|术语描述
|------
|内存屏障<td align="center">memory barriers</td>|是一组处理器指令，用于实现内存操作的顺序限制
|缓冲行<td align="center">cache line</td>|CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行
|原子操作<td align="center">atomic operations</td>|不可中断的一个或一系列操作
|缓存行填充<td align="center">cache line fill</td>|当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存（L1,L2,L3）
|缓存命中<td align="center">cache hit</td>|如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存中读取
|写命中<td align="center">write hit</td>|当处理器将操作数写回到一个内存缓存的区域时，首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存中，这个操作被称为写命中。
|写缺失<td align="center">write misses the cache</td>|一个有效的缓存行被写入到不存在的内存区域

volatile变量修饰的共享变量进行写操作的时候会引发两件事情：

## volatile使用优化

JAVA7并发包中，在使用volatile变量时，用追加字节的方式来优化队列出队和入队的性能<br/>
原因是：对于很多CPU的高速缓存行都是64个字节，当长度不足64个字节时，就会将头节点和尾节点读到一个高速缓存行中，而处理器试图修改头节点时，会锁定整个缓存行，此时尾节点也会被锁定，导致其他处理器不能访问自己高速缓存的尾节点，严重影响队列的入队和出队效率。<br/>
使用追加到64个字节的方式填充满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行中，使头节点和尾节点在修改时不会互相锁定。
